<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>string &mdash; dbprocessing NMC_1 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'NMC_1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <link rel="top" title="dbprocessing NMC_1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">top</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for string</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;A collection of string operations (most are no longer used).</span>

<span class="sd">Warning: most of the code you see here isn&#39;t normally used nowadays.</span>
<span class="sd">Beginning with Python 1.6, many of these functions are implemented as</span>
<span class="sd">methods on the standard string object. They used to be implemented by</span>
<span class="sd">a built-in module called strop, but strop is now obsolete itself.</span>

<span class="sd">Public module variables:</span>

<span class="sd">whitespace -- a string containing all characters considered whitespace</span>
<span class="sd">lowercase -- a string containing all characters considered lowercase letters</span>
<span class="sd">uppercase -- a string containing all characters considered uppercase letters</span>
<span class="sd">letters -- a string containing all characters considered letters</span>
<span class="sd">digits -- a string containing all characters considered decimal digits</span>
<span class="sd">hexdigits -- a string containing all characters considered hexadecimal digits</span>
<span class="sd">octdigits -- a string containing all characters considered octal digits</span>
<span class="sd">punctuation -- a string containing all characters considered punctuation</span>
<span class="sd">printable -- a string containing all characters considered printable</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Some strings for ctype-style character classification</span>
<span class="n">whitespace</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="se">\t\n\r\v\f</span><span class="s1">&#39;</span>
<span class="n">lowercase</span> <span class="o">=</span> <span class="s1">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span>
<span class="n">uppercase</span> <span class="o">=</span> <span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
<span class="n">letters</span> <span class="o">=</span> <span class="n">lowercase</span> <span class="o">+</span> <span class="n">uppercase</span>
<span class="n">ascii_lowercase</span> <span class="o">=</span> <span class="n">lowercase</span>
<span class="n">ascii_uppercase</span> <span class="o">=</span> <span class="n">uppercase</span>
<span class="n">ascii_letters</span> <span class="o">=</span> <span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">ascii_uppercase</span>
<span class="n">digits</span> <span class="o">=</span> <span class="s1">&#39;0123456789&#39;</span>
<span class="n">hexdigits</span> <span class="o">=</span> <span class="n">digits</span> <span class="o">+</span> <span class="s1">&#39;abcdef&#39;</span> <span class="o">+</span> <span class="s1">&#39;ABCDEF&#39;</span>
<span class="n">octdigits</span> <span class="o">=</span> <span class="s1">&#39;01234567&#39;</span>
<span class="n">punctuation</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;!&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~&quot;&quot;&quot;</span>
<span class="n">printable</span> <span class="o">=</span> <span class="n">digits</span> <span class="o">+</span> <span class="n">letters</span> <span class="o">+</span> <span class="n">punctuation</span> <span class="o">+</span> <span class="n">whitespace</span>

<span class="c1"># Case conversion helpers</span>
<span class="c1"># Use str to convert Unicode literal in case of -U</span>
<span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span>
<span class="n">_idmap</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="k">del</span> <span class="n">l</span>

<span class="c1"># Functions which aren&#39;t available as string methods.</span>

<span class="c1"># Capitalize the words in a string, e.g. &quot; aBc  dEf &quot; -&gt; &quot;Abc Def&quot;.</span>
<span class="k">def</span> <span class="nf">capwords</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;capwords(s [,sep]) -&gt; string</span>

<span class="sd">    Split the argument into words using split, capitalize each</span>
<span class="sd">    word using capitalize, and join the capitalized words using</span>
<span class="sd">    join.  If the optional second argument sep is absent or None,</span>
<span class="sd">    runs of whitespace characters are replaced by a single space</span>
<span class="sd">    and leading and trailing whitespace are removed, otherwise</span>
<span class="sd">    sep is used to split and join the words.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">sep</span> <span class="ow">or</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span>


<span class="c1"># Construct a translation string</span>
<span class="n">_idmapL</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">maketrans</span><span class="p">(</span><span class="n">fromstr</span><span class="p">,</span> <span class="n">tostr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;maketrans(frm, to) -&gt; string</span>

<span class="sd">    Return a translation table (a string of 256 bytes long)</span>
<span class="sd">    suitable for use in string.translate.  The strings frm and to</span>
<span class="sd">    must be of the same length.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromstr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tostr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;maketrans arguments must have same length&quot;</span>
    <span class="k">global</span> <span class="n">_idmapL</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_idmapL</span><span class="p">:</span>
        <span class="n">_idmapL</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_idmap</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">_idmapL</span><span class="p">[:]</span>
    <span class="n">fromstr</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">fromstr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fromstr</span><span class="p">)):</span>
        <span class="n">L</span><span class="p">[</span><span class="n">fromstr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tostr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>



<span class="c1">####################################################################</span>
<span class="kn">import</span> <span class="nn">re</span> <span class="kn">as</span> <span class="nn">_re</span>

<span class="k">class</span> <span class="nc">_multimap</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper class for combining multiple mappings.</span>

<span class="sd">    Used by .{safe_,}substitute() to combine the mapping and keyword</span>
<span class="sd">    arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_primary</span> <span class="o">=</span> <span class="n">primary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_secondary</span> <span class="o">=</span> <span class="n">secondary</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_secondary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_TemplateMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="s2">r&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">%(delim)s</span><span class="s2">(?:</span>
<span class="s2">      (?P&lt;escaped&gt;</span><span class="si">%(delim)s</span><span class="s2">) |   # Escape sequence of two delimiters</span>
<span class="s2">      (?P&lt;named&gt;</span><span class="si">%(id)s</span><span class="s2">)      |   # delimiter and a Python identifier</span>
<span class="s2">      {(?P&lt;braced&gt;</span><span class="si">%(id)s</span><span class="s2">)}   |   # delimiter and a braced identifier</span>
<span class="s2">      (?P&lt;invalid&gt;)              # Other ill-formed delimiter exprs</span>
<span class="s2">    )</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_TemplateMetaclass</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;pattern&#39;</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">_TemplateMetaclass</span><span class="o">.</span><span class="n">pattern</span> <span class="o">%</span> <span class="p">{</span>
                <span class="s1">&#39;delim&#39;</span> <span class="p">:</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">delimiter</span><span class="p">),</span>
                <span class="s1">&#39;id&#39;</span>    <span class="p">:</span> <span class="n">cls</span><span class="o">.</span><span class="n">idpattern</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">_re</span><span class="o">.</span><span class="n">IGNORECASE</span> <span class="o">|</span> <span class="n">_re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Template</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A string class for supporting $-substitutions.&quot;&quot;&quot;</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">_TemplateMetaclass</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="s1">&#39;$&#39;</span>
    <span class="n">idpattern</span> <span class="o">=</span> <span class="s1">r&#39;[_a-z][_a-z0-9]*&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="n">template</span>

    <span class="c1"># Search for $$, $identifier, ${identifier}, and any bare $&#39;s</span>

    <span class="k">def</span> <span class="nf">_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mo</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;invalid&#39;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">colno</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">lineno</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colno</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">lineno</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid placeholder in string: line </span><span class="si">%d</span><span class="s1">, col </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">lineno</span><span class="p">,</span> <span class="n">colno</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;descriptor &#39;substitute&#39; of &#39;Template&#39; object &quot;</span>
                            <span class="s2">&quot;needs an argument&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># allow the &quot;self&quot; keyword be passed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Too many positional arguments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">kws</span>
        <span class="k">elif</span> <span class="n">kws</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">_multimap</span><span class="p">(</span><span class="n">kws</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Helper function for .sub()</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">mo</span><span class="p">):</span>
            <span class="c1"># Check the most common path first.</span>
            <span class="n">named</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;named&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;braced&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">named</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">named</span><span class="p">]</span>
                <span class="c1"># We use this idiom instead of str() because the latter will</span>
                <span class="c1"># fail if val is a Unicode containing non-ASCII characters.</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;escaped&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimiter</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;invalid&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">(</span><span class="n">mo</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized named group in pattern&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">convert</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">safe_substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;descriptor &#39;safe_substitute&#39; of &#39;Template&#39; object &quot;</span>
                            <span class="s2">&quot;needs an argument&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># allow the &quot;self&quot; keyword be passed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Too many positional arguments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">kws</span>
        <span class="k">elif</span> <span class="n">kws</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">_multimap</span><span class="p">(</span><span class="n">kws</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Helper function for .sub()</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">mo</span><span class="p">):</span>
            <span class="n">named</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;named&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;braced&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">named</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We use this idiom instead of str() because the latter</span>
                    <span class="c1"># will fail if val is a Unicode containing non-ASCII</span>
                    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">named</span><span class="p">],)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;escaped&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimiter</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;invalid&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized named group in pattern&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">convert</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span>



<span class="c1">####################################################################</span>
<span class="c1"># NOTE: Everything below here is deprecated.  Use string methods instead.</span>
<span class="c1"># This stuff will go away in Python 3.0.</span>

<span class="c1"># Backward compatible names for exceptions</span>
<span class="n">index_error</span> <span class="o">=</span> <span class="ne">ValueError</span>
<span class="n">atoi_error</span> <span class="o">=</span> <span class="ne">ValueError</span>
<span class="n">atof_error</span> <span class="o">=</span> <span class="ne">ValueError</span>
<span class="n">atol_error</span> <span class="o">=</span> <span class="ne">ValueError</span>

<span class="c1"># convert UPPER CASE letters to lower case</span>
<span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;lower(s) -&gt; string</span>

<span class="sd">    Return a copy of the string s converted to lowercase.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

<span class="c1"># Convert lower case letters to UPPER CASE</span>
<span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;upper(s) -&gt; string</span>

<span class="sd">    Return a copy of the string s converted to uppercase.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

<span class="c1"># Swap lower case letters and UPPER CASE</span>
<span class="k">def</span> <span class="nf">swapcase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;swapcase(s) -&gt; string</span>

<span class="sd">    Return a copy of the string s with upper case characters</span>
<span class="sd">    converted to lowercase and vice versa.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>

<span class="c1"># Strip leading and trailing tabs and spaces</span>
<span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;strip(s [,chars]) -&gt; string</span>

<span class="sd">    Return a copy of the string s with leading and trailing</span>
<span class="sd">    whitespace removed.</span>
<span class="sd">    If chars is given and not None, remove characters in chars instead.</span>
<span class="sd">    If chars is unicode, S will be converted to unicode before stripping.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>

<span class="c1"># Strip leading tabs and spaces</span>
<span class="k">def</span> <span class="nf">lstrip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;lstrip(s [,chars]) -&gt; string</span>

<span class="sd">    Return a copy of the string s with leading whitespace removed.</span>
<span class="sd">    If chars is given and not None, remove characters in chars instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>

<span class="c1"># Strip trailing tabs and spaces</span>
<span class="k">def</span> <span class="nf">rstrip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;rstrip(s [,chars]) -&gt; string</span>

<span class="sd">    Return a copy of the string s with trailing whitespace removed.</span>
<span class="sd">    If chars is given and not None, remove characters in chars instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>


<span class="c1"># Split a string into a list of space/tab-separated words</span>
<span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;split(s [,sep [,maxsplit]]) -&gt; list of strings</span>

<span class="sd">    Return a list of the words in the string s, using sep as the</span>
<span class="sd">    delimiter string.  If maxsplit is given, splits at no more than</span>
<span class="sd">    maxsplit places (resulting in at most maxsplit+1 words).  If sep</span>
<span class="sd">    is not specified or is None, any whitespace string is a separator.</span>

<span class="sd">    (split and splitfields are synonymous)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">maxsplit</span><span class="p">)</span>
<span class="n">splitfields</span> <span class="o">=</span> <span class="n">split</span>

<span class="c1"># Split a string into a list of space/tab-separated words</span>
<span class="k">def</span> <span class="nf">rsplit</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;rsplit(s [,sep [,maxsplit]]) -&gt; list of strings</span>

<span class="sd">    Return a list of the words in the string s, using sep as the</span>
<span class="sd">    delimiter string, starting at the end of the string and working</span>
<span class="sd">    to the front.  If maxsplit is given, at most maxsplit splits are</span>
<span class="sd">    done. If sep is not specified or is None, any whitespace string</span>
<span class="sd">    is a separator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">maxsplit</span><span class="p">)</span>

<span class="c1"># Join fields with optional separator</span>
<span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;join(list [,sep]) -&gt; string</span>

<span class="sd">    Return a string composed of the words in list, with</span>
<span class="sd">    intervening occurrences of sep.  The default separator is a</span>
<span class="sd">    single space.</span>

<span class="sd">    (joinfields and join are synonymous)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="n">joinfields</span> <span class="o">=</span> <span class="n">join</span>

<span class="c1"># Find substring, raise exception if not found</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;index(s, sub [,start [,end]]) -&gt; int</span>

<span class="sd">    Like find but raises ValueError when the substring is not found.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Find last substring, raise exception if not found</span>
<span class="k">def</span> <span class="nf">rindex</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;rindex(s, sub [,start [,end]]) -&gt; int</span>

<span class="sd">    Like rfind but raises ValueError when the substring is not found.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">rindex</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Count non-overlapping occurrences of substring</span>
<span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;count(s, sub[, start[,end]]) -&gt; int</span>

<span class="sd">    Return the number of occurrences of substring sub in string</span>
<span class="sd">    s[start:end].  Optional arguments start and end are</span>
<span class="sd">    interpreted as in slice notation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Find substring, return -1 if not found</span>
<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;find(s, sub [,start [,end]]) -&gt; in</span>

<span class="sd">    Return the lowest index in s where substring sub is found,</span>
<span class="sd">    such that sub is contained within s[start,end].  Optional</span>
<span class="sd">    arguments start and end are interpreted as in slice notation.</span>

<span class="sd">    Return -1 on failure.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Find last substring, return -1 if not found</span>
<span class="k">def</span> <span class="nf">rfind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;rfind(s, sub [,start [,end]]) -&gt; int</span>

<span class="sd">    Return the highest index in s where substring sub is found,</span>
<span class="sd">    such that sub is contained within s[start,end].  Optional</span>
<span class="sd">    arguments start and end are interpreted as in slice notation.</span>

<span class="sd">    Return -1 on failure.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># for a bit of speed</span>
<span class="n">_float</span> <span class="o">=</span> <span class="nb">float</span>
<span class="n">_int</span> <span class="o">=</span> <span class="nb">int</span>
<span class="n">_long</span> <span class="o">=</span> <span class="nb">long</span>

<span class="c1"># Convert string to float</span>
<span class="k">def</span> <span class="nf">atof</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;atof(s) -&gt; float</span>

<span class="sd">    Return the floating point number represented by the string s.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="c1"># Convert string to integer</span>
<span class="k">def</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">s</span> <span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;atoi(s [,base]) -&gt; int</span>

<span class="sd">    Return the integer represented by the string s in the given</span>
<span class="sd">    base, which defaults to 10.  The string s must consist of one</span>
<span class="sd">    or more digits, possibly preceded by a sign.  If base is 0, it</span>
<span class="sd">    is chosen from the leading characters of s, 0 for octal, 0x or</span>
<span class="sd">    0X for hexadecimal.  If base is 16, a preceding 0x or 0X is</span>
<span class="sd">    accepted.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>


<span class="c1"># Convert string to long integer</span>
<span class="k">def</span> <span class="nf">atol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;atol(s [,base]) -&gt; long</span>

<span class="sd">    Return the long integer represented by the string s in the</span>
<span class="sd">    given base, which defaults to 10.  The string s must consist</span>
<span class="sd">    of one or more digits, possibly preceded by a sign.  If base</span>
<span class="sd">    is 0, it is chosen from the leading characters of s, 0 for</span>
<span class="sd">    octal, 0x or 0X for hexadecimal.  If base is 16, a preceding</span>
<span class="sd">    0x or 0X is accepted.  A trailing L or l is not accepted,</span>
<span class="sd">    unless base is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_long</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>


<span class="c1"># Left-justify a string</span>
<span class="k">def</span> <span class="nf">ljust</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ljust(s, width[, fillchar]) -&gt; string</span>

<span class="sd">    Return a left-justified version of s, in a field of the</span>
<span class="sd">    specified width, padded with spaces as needed.  The string is</span>
<span class="sd">    never truncated.  If specified the fillchar is used instead of spaces.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Right-justify a string</span>
<span class="k">def</span> <span class="nf">rjust</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;rjust(s, width[, fillchar]) -&gt; string</span>

<span class="sd">    Return a right-justified version of s, in a field of the</span>
<span class="sd">    specified width, padded with spaces as needed.  The string is</span>
<span class="sd">    never truncated.  If specified the fillchar is used instead of spaces.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Center a string</span>
<span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;center(s, width[, fillchar]) -&gt; string</span>

<span class="sd">    Return a center version of s, in a field of the specified</span>
<span class="sd">    width. padded with spaces as needed.  The string is never</span>
<span class="sd">    truncated.  If specified the fillchar is used instead of spaces.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="c1"># Zero-fill a number, e.g., (12, 3) --&gt; &#39;012&#39; and (-3, 3) --&gt; &#39;-03&#39;</span>
<span class="c1"># Decadent feature: the argument may be a string or a number</span>
<span class="c1"># (Use of this is deprecated; it should be a string as with ljust c.s.)</span>
<span class="k">def</span> <span class="nf">zfill</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;zfill(x, width) -&gt; string</span>

<span class="sd">    Pad a numeric string x with zeros on the left, to fill a field</span>
<span class="sd">    of the specified width.  The string x is never truncated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>

<span class="c1"># Expand tabs in a string.</span>
<span class="c1"># Doesn&#39;t take non-printing chars into account, but does understand \n.</span>
<span class="k">def</span> <span class="nf">expandtabs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tabsize</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;expandtabs(s [,tabsize]) -&gt; string</span>

<span class="sd">    Return a copy of the string s with all tab characters replaced</span>
<span class="sd">    by the appropriate number of spaces, depending on the current</span>
<span class="sd">    column, and the tabsize (default 8).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="n">tabsize</span><span class="p">)</span>

<span class="c1"># Character translation through look-up table.</span>
<span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">deletions</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;translate(s,table [,deletions]) -&gt; string</span>

<span class="sd">    Return a copy of the string s, where all characters occurring</span>
<span class="sd">    in the optional argument deletions are removed, and the</span>
<span class="sd">    remaining characters have been mapped through the given</span>
<span class="sd">    translation table, which must be a string of length 256.  The</span>
<span class="sd">    deletions argument is not allowed for Unicode strings.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deletions</span> <span class="ow">or</span> <span class="n">table</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">deletions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Add s[:0] so that if s is Unicode and table is an 8-bit string,</span>
        <span class="c1"># table is converted to Unicode.  This means that table *cannot*</span>
        <span class="c1"># be a dictionary -- for that feature, use u.translate() directly.</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Capitalize a string, e.g. &quot;aBc  dEf&quot; -&gt; &quot;Abc  def&quot;.</span>
<span class="k">def</span> <span class="nf">capitalize</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;capitalize(s) -&gt; string</span>

<span class="sd">    Return a copy of the string s with only its first character</span>
<span class="sd">    capitalized.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>

<span class="c1"># Substring replacement (global)</span>
<span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">maxreplace</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;replace (str, old, new[, maxreplace]) -&gt; string</span>

<span class="sd">    Return a copy of string str with all occurrences of substring</span>
<span class="sd">    old replaced by new. If the optional argument maxreplace is</span>
<span class="sd">    given, only the first maxreplace occurrences are replaced.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">maxreplace</span><span class="p">)</span>


<span class="c1"># Try importing optional built-in module &quot;strop&quot; -- if it exists,</span>
<span class="c1"># it redefines some string operations that are 100-1000 times faster.</span>
<span class="c1"># It also defines values for whitespace, lowercase and uppercase</span>
<span class="c1"># that match &lt;ctype.h&gt;&#39;s definitions.</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">strop</span> <span class="kn">import</span> <span class="n">maketrans</span><span class="p">,</span> <span class="n">lowercase</span><span class="p">,</span> <span class="n">uppercase</span><span class="p">,</span> <span class="n">whitespace</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="n">lowercase</span> <span class="o">+</span> <span class="n">uppercase</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>                                          <span class="c1"># Use the original versions</span>

<span class="c1">########################################################################</span>
<span class="c1"># the Formatter class</span>
<span class="c1"># see PEP 3101 for details and purpose of this class</span>

<span class="c1"># The hard parts are reused from the C implementation.  They&#39;re exposed as &quot;_&quot;</span>
<span class="c1"># prefixed methods of str and unicode.</span>

<span class="c1"># The overall parser is implemented in str._formatter_parser.</span>
<span class="c1"># The field name parser is implemented in str._formatter_field_name_split</span>

<span class="k">class</span> <span class="nc">Formatter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;descriptor &#39;format&#39; of &#39;Formatter&#39; object &quot;</span>
                            <span class="s2">&quot;needs an argument&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># allow the &quot;self&quot; keyword be passed</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">format_string</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># allow the &quot;format_string&quot; keyword be passed</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;format_string&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">format_string</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;format_string&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;format() missing 1 required positional &quot;</span>
                                <span class="s2">&quot;argument: &#39;format_string&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vformat</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">vformat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">used_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vformat</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">used_args</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_unused_args</span><span class="p">(</span><span class="n">used_args</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_vformat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">used_args</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">recursion_depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Max string recursion exceeded&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">literal_text</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">,</span> <span class="n">conversion</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">format_string</span><span class="p">):</span>

            <span class="c1"># output the literal text</span>
            <span class="k">if</span> <span class="n">literal_text</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literal_text</span><span class="p">)</span>

            <span class="c1"># if there&#39;s a field, output it</span>
            <span class="k">if</span> <span class="n">field_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># this is some markup, find the object and do</span>
                <span class="c1">#  the formatting</span>

                <span class="c1"># given the field_name, find the object it references</span>
                <span class="c1">#  and the argument it came from</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">arg_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">used_args</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg_used</span><span class="p">)</span>

                <span class="c1"># do any conversion on the resulting object</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_field</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">conversion</span><span class="p">)</span>

                <span class="c1"># expand the format spec, if needed</span>
                <span class="n">format_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vformat</span><span class="p">(</span><span class="n">format_spec</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span>
                                            <span class="n">used_args</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># format the object and append to the result</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format_field</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">check_unused_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">used_args</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>


    <span class="k">def</span> <span class="nf">format_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">convert_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">conversion</span><span class="p">):</span>
        <span class="c1"># do any conversion on the resulting object</span>
        <span class="k">if</span> <span class="n">conversion</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">conversion</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">conversion</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown conversion specifier {0!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conversion</span><span class="p">))</span>


    <span class="c1"># returns an iterable that contains tuples of the form:</span>
    <span class="c1"># (literal_text, field_name, format_spec, conversion)</span>
    <span class="c1"># literal_text can be zero length</span>
    <span class="c1"># field_name can be None, in which case there&#39;s no</span>
    <span class="c1">#  object to format and output</span>
    <span class="c1"># if field_name is not None, it is looked up, formatted</span>
    <span class="c1">#  with format_spec and conversion and then used</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_string</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">format_string</span><span class="o">.</span><span class="n">_formatter_parser</span><span class="p">()</span>


    <span class="c1"># given a field_name, find the object it references.</span>
    <span class="c1">#  field_name:   the field being looked up, e.g. &quot;0.name&quot;</span>
    <span class="c1">#                 or &quot;lookup[3]&quot;</span>
    <span class="c1">#  used_args:    a set of which args have been used</span>
    <span class="c1">#  args, kwargs: as passed in to vformat</span>
    <span class="k">def</span> <span class="nf">get_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">field_name</span><span class="o">.</span><span class="n">_formatter_field_name_split</span><span class="p">()</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># loop through the rest of the field_name, doing</span>
        <span class="c1">#  getattr or getitem as needed</span>
        <span class="k">for</span> <span class="n">is_attr</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_attr</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">first</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">top</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Brian Larsen, Jonathan Niehof.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>